<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Apprentissage automatique interprétable</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../05-interpretable_models/05.7-other-interpretable-models.html" rel="next">
<link href="../05-interpretable_models/05.5-decision-rules.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Pas de résultats",
    "search-matching-documents-text": "documents trouvés",
    "search-copy-link-title": "Copier le lien vers la recherche",
    "search-hide-matches-text": "Cacher les correspondances additionnelles",
    "search-more-match-text": "correspondance de plus dans ce document",
    "search-more-matches-text": "correspondances de plus dans ce document",
    "search-clear-button-title": "Effacer",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Annuler",
    "search-submit-button-title": "Envoyer",
    "search-label": "Recherche"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Basculer la barre latérale" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../05-interpretable_models/index.html">5 - Modèles interprétables</a></li><li class="breadcrumb-item"><a href="../05-interpretable_models/05.6-rulefit.html">5.6 - Ajustement des règles</a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Basculer la barre latérale" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Apprentissage automatique interprétable</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Recherche"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../00-summary/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Résumé</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../01-preface/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1 - Préface de l’auteur</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../02-introduction/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2 - Introduction</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Basculer la section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../02-introduction/02.1-short_stories.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2.1 - Quelques histoires</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../02-introduction/02.2-ml_definitions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2.2 - Qu’est-ce que l’apprentissage automatique ?</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../02-introduction/02.3-terminology.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2.3 - Terminologie</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../03-interpretability/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3 - Interprétabilité</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Basculer la section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../03-interpretability/03.1-importance_of_interpretability.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3.1 - Importance de l’Interprétabilité</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../03-interpretability/03.2-taxonomy_of_interpretability_methods.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3.2 - Taxonomie des Méthodes d’Interprétabilité</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../03-interpretability/03.3-scope_of_interpretability.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3.3 - Portée de l’Interprétabilité</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../03-interpretability/03.4-evaluation_of_interpretability.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3.4 - Evaluation de l’interprétabilité</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../03-interpretability/03.5-properties_of_explanations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3.5 - Propriétés des Explications</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../03-interpretability/03.6-human_friendly_explanations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3.6 - Explications conviviales pour l’être humain</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../04-datasets/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4 - Jeux de données</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Basculer la section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../04-datasets/04.1-datasets.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4.1 - Location de vélo (Régression)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../04-datasets/04.2-datasets.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4.2 - Commentaires indésirables sur YouTube (Classification de Texte)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../04-datasets/04.3-datasets.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4.3 - Facteurs de Risque du Cancer du Col de l’Uterus (Classification)</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../05-interpretable_models/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5 - Modèles interprétables</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true" aria-label="Basculer la section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../05-interpretable_models/05.1-linear-regression.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5.1 - Régéression linéaire</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../05-interpretable_models/05.2-logistic-regression.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5.2 - Régéression logistique</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../05-interpretable_models/05.3-glm-gam-more.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5.3 - GLM, GAM et plus</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../05-interpretable_models/05.4-decision-tree.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5.4 - Arbre de décision</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../05-interpretable_models/05.5-decision-rules.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5.5 - Règles de décision</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../05-interpretable_models/05.6-rulefit.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">5.6 - Ajustement des règles</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../05-interpretable_models/05.7-other-interpretable-models.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5.7 - Autres modèles interprétables</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../06-model_agnostic_methods/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">6 - Méthodes indépendantes du modèle</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../07-example/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">7 - Explications basées sur des exemples</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../08-global_model_agnostic_methods/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8 - Méthodes globales indépendantes du modèle</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true" aria-label="Basculer la section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../08-global_model_agnostic_methods/08.1-pdp.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8.1 - Diagramme de dépendance partielle (PDP)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../08-global_model_agnostic_methods/08.2-ale.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8.2 - Graphique des effets locaux accumulés (ALE)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../08-global_model_agnostic_methods/08.3-feature-interaction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8.3 - Interactions avec les fonctionnalités</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../08-global_model_agnostic_methods/08.4-functional-decomposition.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8.4 - Functional Decomposition</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../08-global_model_agnostic_methods/08.5-permutation-feature-importance.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8.5 - Décomposition fonctionnelle</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../08-global_model_agnostic_methods/08.6-global-surrogate.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8.6 - Substitut global</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../08-global_model_agnostic_methods/08.7-prototype-criticisms.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8.7 - Prototypes et critiques</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../09-local_model_agnostic_methods/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">9 - Méthodes locales indépendantes du modèle</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="true" aria-label="Basculer la section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../09-local_model_agnostic_methods/09.1-ice.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">9.1 - Attente Conditionnelle Individuelle (<em>Individual Conditional Expectation - ICE</em>)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../09-local_model_agnostic_methods/09.2-lime.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">9.2 - Substitut local (LIME)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../09-local_model_agnostic_methods/09.3-counterfactual.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">9.3 - Explications contrefactuelles</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../09-local_model_agnostic_methods/09.4-anchors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">9.4 - Règles de portée (ancres)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../09-local_model_agnostic_methods/09.5-shapley.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">9.5 - Valeurs de Shapley</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../09-local_model_agnostic_methods/09.6-shap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">9.6 - SHAP (SHapley Additive exPlanations)</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../10-neuralnet/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">10 - Interprétation d'un réseau de neurone</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="true" aria-label="Basculer la section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../10-neuralnet/10.1-learned-features.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">10.1 - Caractéristiques apprises</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../10-neuralnet/10.2-pixel-attribution.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">10.2 - Attribution de pixel</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../10-neuralnet/10.3-concepts.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">10.3 - Détecter les concepts</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../10-neuralnet/10.4-adversarial-examples.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">10.4 - Exemples adverses</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../10-neuralnet/10.5-influential-instances.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">10.5 - Instances Influentes</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../11-future/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">11 - Un Regard dans une boule de cristal</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" aria-expanded="true" aria-label="Basculer la section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../11-future/11.1-future-ml.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">11.1 - L’avenir de l’apprentissage automatique</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../11-future/11.2-future-interpretability.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">11.2 - L’avenir de l’interprétabilité</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../12-contribute/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">12 - Contribuer à ce livre</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../13-citation/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">13 - Citer ce livre</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../14-translations/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">14 - Traductions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../15-acknowledgements/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">15 - Remerciements</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="4">
    <h2 id="toc-title">Dans cette page</h2>
   
  <ul>
  <li><a href="#ajustement-des-règles" id="toc-ajustement-des-règles" class="nav-link active" data-scroll-target="#ajustement-des-règles">5.6 - Ajustement des règles</a>
  <ul>
  <li><a href="#interprétation-et-exemple" id="toc-interprétation-et-exemple" class="nav-link" data-scroll-target="#interprétation-et-exemple">5.6.1 - Interprétation et exemple</a></li>
  <li><a href="#théorie" id="toc-théorie" class="nav-link" data-scroll-target="#théorie">5.6.2 - Théorie</a></li>
  <li><a href="#avantages" id="toc-avantages" class="nav-link" data-scroll-target="#avantages">5.6.3 - Avantages</a></li>
  <li><a href="#inconvénients" id="toc-inconvénients" class="nav-link" data-scroll-target="#inconvénients">5.6.4 - Inconvénients</a></li>
  <li><a href="#logiciels-et-alternatives" id="toc-logiciels-et-alternatives" class="nav-link" data-scroll-target="#logiciels-et-alternatives">5.6.5 - Logiciels et alternatives</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../05-interpretable_models/index.html">5 - Modèles interprétables</a></li><li class="breadcrumb-item"><a href="../05-interpretable_models/05.6-rulefit.html">5.6 - Ajustement des règles</a></li></ol></nav>
<div class="quarto-title">
</div>



<div class="quarto-title-meta">

    
  
    <div>
    <div class="quarto-title-meta-heading">Modifié</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">10 mai 2024</p>
    </div>
  </div>
    
  </div>
  


</header>


<section id="ajustement-des-règles" class="level2">
<h2 class="anchored" data-anchor-id="ajustement-des-règles">5.6 - Ajustement des règles</h2>
<p>L’algorithme RuleFit de Friedman et Popescu (2008)<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> apprend des modèles linéaires clairsemés qui incluent des effets d’interaction automatiquement détectés sous la forme de règles de décision.</p>
<p>Le modèle de régression linéaire ne tient pas compte des interactions entre les caractéristiques. Ne serait-il pas pratique d’avoir un modèle aussi simple et interprétable que les modèles linéaires, mais intégrant également des interactions de fonctionnalités ? RuleFit comble cette lacune. RuleFit apprend un modèle linéaire clairsemé avec les fonctionnalités d’origine ainsi qu’un certain nombre de nouvelles fonctionnalités qui sont des règles de décision. Ces nouvelles fonctionnalités capturent les interactions entre les fonctionnalités d’origine. RuleFit génère automatiquement ces fonctionnalités à partir d’arbres de décision. Chaque chemin à travers un arbre peut être transformé en règle de décision en combinant les décisions fractionnées en une règle. Les prédictions de nœuds sont ignorées et seules les divisions sont utilisées dans les règles de décision :</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/rulefit.jpg" class="img-fluid figure-img" data-align="center"></p>
<figcaption>4 règles peuvent être générées à partir d’un arbre à 3 nœuds terminaux.</figcaption>
</figure>
</div>
<p>D’où viennent ces arbres de décision ? Les arbres sont dressés pour prédire le résultat qui nous intéresse. Cela garantit que les divisions sont significatives pour la tâche de prédiction. Tout algorithme générant de nombreux arbres peut être utilisé pour RuleFit, par exemple une forêt aléatoire. Chaque arbre est décomposé en règles de décision qui sont utilisées comme fonctionnalités supplémentaires dans un modèle de régression linéaire clairsemé (Lasso).</p>
<p>L’article RuleFit utilise les données sur le logement de Boston pour illustrer ceci : l’objectif est de prédire la valeur médiane des maisons d’un quartier de Boston. L’une des règles générées par RuleFit est : IF <code>number of rooms &gt; 6.64</code> ET <code>concentration of nitric oxide &lt; 0.67</code> ALORS 1 SINON 0.</p>
<p>RuleFit est également livré avec une mesure de l’importance des fonctionnalités qui permet d’identifier les termes linéaires et les règles importants pour les prédictions. L’importance des caractéristiques est calculée à partir des poids du modèle de régression. La mesure d’importance peut être agrégée pour les caractéristiques originales (qui sont utilisées sous leur forme « brute » et éventuellement dans de nombreuses règles de décision).</p>
<p>RuleFit introduit également des tracés de dépendance partielle pour montrer le changement moyen de la prédiction en modifiant une fonctionnalité. Le tracé de dépendance partielle est une méthode indépendante du modèle qui peut être utilisée avec n’importe quel modèle et est expliquée dans le <a href="../08-global_model_agnostic_methods/08.1-pdp.html">chapitre du livre sur les tracés de dépendance partielle</a>.</p>
<section id="interprétation-et-exemple" class="level3">
<h3 class="anchored" data-anchor-id="interprétation-et-exemple">5.6.1 - Interprétation et exemple</h3>
<p>Puisque RuleFit estime finalement un modèle linéaire, l’interprétation est la même que pour <a href="../05-interpretable_models/05.1-linear-regression.html">les modèles linéaires</a> « normaux » . La seule différence est que le modèle possède de nouvelles fonctionnalités dérivées des règles de décision. Les règles de décision sont des caractéristiques binaires : une valeur de 1 signifie que toutes les conditions de la règle sont remplies, sinon la valeur est 0. Pour les termes linéaires dans RuleFit, l’interprétation est la même que dans les modèles de régression linéaire : si la caractéristique augmente d’une unité , le résultat prédit change en fonction du poids des caractéristiques correspondant.</p>
<p>Dans cet exemple, nous utilisons RuleFit pour prédire le nombre de <a href="../04-datasets/04.1-datasets.html">vélos loués</a> un jour donné. Le tableau présente cinq des règles générées par RuleFit, ainsi que leurs poids et importances Lasso. Le calcul est expliqué plus loin dans le chapitre.</p>
<p><img src="../images2/5_6_1_table_1.png" class="img-fluid" data-align="center"></p>
<p>La règle la plus importante était : « jours_depuis_2011 &gt; 111 &amp; temps de repos (« GOOD », « MISTY ») » et le poids correspondant est 795. L’interprétation est : Si jours_depuis_2011 &gt; 111 &amp; temps de repos (« GOOD », « MISTY ») , le nombre prévu de vélos augmente de 795, lorsque toutes les autres valeurs de caractéristiques restent fixes. Au total, 278 règles de ce type ont été créées à partir des 8 fonctionnalités originales. Beaucoup! Mais grâce au Lasso, seuls 59 des 278 ont un poids différent de 0.</p>
<p>Le calcul de l’importance des caractéristiques globales révèle que la tendance de la température et du temps sont les caractéristiques les plus importantes :</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images2/5_6_1_figure_1.png" class="img-fluid figure-img" data-align="center"></p>
<figcaption>Mesures d’importance des caractéristiques pour un modèle RuleFit prédisant le nombre de vélos. Les caractéristiques les plus importantes pour les prévisions étaient la température et la tendance temporelle.</figcaption>
</figure>
</div>
<p>La mesure de l’importance de la fonctionnalité inclut l’importance du terme brut de la fonctionnalité et toutes les règles de décision dans lesquelles la fonctionnalité apparaît.</p>
<p><strong>Modèle d’interprétation</strong></p>
<p>L’interprétation est analogue aux modèles linéaires : le résultat prévu change de <span class="math inline">\(\beta_j\)</span> si la fonctionnalité <span class="math inline">\(x_j\)</span> change d’une unité, à condition que toutes les autres caractéristiques restent inchangées. L’interprétation pondérée d’une règle de décision est un cas particulier : si toutes les conditions d’une règle de décision <span class="math inline">\(r_k\)</span> s’appliquent, le résultat prévu change de <span class="math inline">\(\alpha_k\)</span> (le poids appris de la règle <span class="math inline">\(r_k\)</span> dans le modèle linéaire).</p>
<p>Pour la classification (en utilisant la régression logistique au lieu de la régression linéaire) : Si toutes les conditions de la règle de décision <span class="math inline">\(r_k\)</span> s’appliquent, les chances d’un événement ou d’un non-événement changent d’un facteur de <span class="math inline">\(\alpha_k\)</span>.</p>
</section>
<section id="théorie" class="level3">
<h3 class="anchored" data-anchor-id="théorie">5.6.2 - Théorie</h3>
<p>Examinons plus en détail les détails techniques de l’algorithme RuleFit. RuleFit se compose de deux composants : le premier composant crée des « règles » à partir d’arbres de décision et le deuxième composant ajuste un modèle linéaire avec les fonctionnalités d’origine et les nouvelles règles en entrée (d’où le nom « RuleFit »).</p>
<p><strong>Étape 1 : Génération de règles</strong></p>
<p>A quoi ressemble une règle ? Les règles générées par l’algorithme ont une forme simple. Par exemple : SI <code>x2 &lt; 3</code> ET <code>x5 &lt; 7</code> ALORS 1 ELSE 0. Les règles sont construites en décomposant des arbres de décision : Tout chemin vers un nœud dans un arbre peut être converti en règle de décision. Les arbres utilisés pour les règles sont ajustés pour prédire le résultat cible. Par conséquent, les divisions et les règles qui en résultent sont optimisées pour prédire le résultat qui vous intéresse. Vous enchaînez simplement les décisions binaires qui mènent à un certain nœud avec « ET », et voilà, vous avez une règle. Il est souhaitable de générer un grand nombre de règles diverses et significatives. L’augmentation de gradient est utilisée pour ajuster un ensemble d’arbres de décision en régressant ou en classant y avec vos fonctionnalités d’origine X. Chaque arbre résultant est converti en plusieurs règles. Non seulement les arbres améliorés, mais n’importe quel algorithme d’ensemble d’arbres peut être utilisé pour générer les arbres pour RuleFit. Un ensemble d’arbres peut être décrit avec cette formule générale :</p>
<p><span class="math display">\[\hat{f}(x) = a_0+\sum_{m=1}^M a_m \hat{f}_m(X)\]</span></p>
<p>M est le nombre d’arbres et <span class="math inline">\(\hat{f}_m(x)\)</span> est la fonction de prédiction du m-ième arbre. Les <span class="math inline">\(a\)</span> sont les poids. Les ensembles en sac, la forêt aléatoire, AdaBoost et MART produisent des ensembles d’arbres et peuvent être utilisés pour RuleFit.</p>
<p>Nous créons les règles à partir de tous les arbres de l’ensemble. Chaque règle <span class="math inline">\(r_m\)</span> prend la forme de :</p>
<p><span class="math display">\[r_m(x) = \prod_{j\in\text{T}_m}I(x_j\in{}s_{jm})\]</span></p>
<p>où <span class="math inline">\(\text{T}_{m}\)</span> est l’ensemble des fonctionnalités utilisées dans le m-ème arbre, I est la fonction indicatrice qui vaut <span class="math inline">\(1\)</span> lorsque la fonctionnalité <span class="math inline">\(x_j\)</span> est dans le sous-ensemble spécifié de valeurs <span class="math inline">\(s\)</span> pour la <span class="math inline">\(j^{ème}\)</span> fonctionnalité (comme spécifié par les divisions d’arbre) et <span class="math inline">\(0\)</span> sinon. Pour les fonctionnalités numériques, <span class="math inline">\(s_{jm}\)</span> est un intervalle dans la plage de valeurs de la fonctionnalité. L’intervalle ressemble à l’un des deux cas :</p>
<p><span class="math display">\[x_{s_{jm},\text{lower}}&lt;x_j\]</span></p>
<p><span class="math display">\[x_j&lt;x_{s_{jm},upper}\]</span></p>
<p>Des divisions supplémentaires dans cette fonctionnalité pourraient conduire à des intervalles plus compliqués. Pour les fonctionnalités catégorielles, le sous-ensemble s contient certaines catégories spécifiques de la fonctionnalité.</p>
<p>Un exemple inventé pour l’ensemble de données de location de vélos :</p>
<p><span class="math display">\[\begin{align*}
r_{17}(x) &amp; = I(x_{\text{temp}}&lt;15) . I(x_{\text{weather}} \in \{\text{good},\text{cloudy}\}) \\
    &amp; . I(10\leq x_{\text{windspeed}}&lt;20)
\end{align*}\]</span></p>
<p>Cette règle renvoie 1 si les trois conditions sont remplies, sinon 0. RuleFit extrait toutes les règles possibles d’un arbre, pas seulement des nœuds feuilles. Ainsi, une autre règle qui serait créée est :</p>
<p><span class="math display">\[r_{18}(x) = I(x_{\text{temp}}&lt;15) . I(x_{\text{weather}} \in \{\text{good},\text{cloudy}\})\]</span></p>
<p>Au total, le nombre de règles créées à partir d’un ensemble de M arbres avec <span class="math inline">\(t_m\)</span> les noeuds terminaux sont chacun :</p>
<p><span class="math display">\[K = \sum_{m=1}^M2(t_m-1)\]</span></p>
<p>Une astuce introduite par les auteurs de RuleFit consiste à apprendre des arbres avec une profondeur aléatoire afin de générer de nombreuses règles diverses de longueurs différentes. Notez que nous supprimons la valeur prédite dans chaque nœud et ne conservons que les conditions qui nous conduisent à un nœud, puis nous créons une règle à partir de celui-ci. La pondération des règles de décision se fait à l’étape 2 de RuleFit.</p>
<p>Une autre façon de voir l’étape 1 : RuleFit génère un nouvel ensemble de fonctionnalités à partir de vos fonctionnalités d’origine. Ces fonctionnalités sont binaires et peuvent représenter des interactions assez complexes de vos fonctionnalités d’origine. Les règles sont choisies pour maximiser la tâche de prédiction. Les règles sont automatiquement générées à partir de la matrice de covariables X. Vous pouvez simplement voir les règles comme de nouvelles fonctionnalités basées sur vos fonctionnalités d’origine.</p>
<p><strong>Étape 2 : Modèle linéaire clairsemé</strong></p>
<p>Vous obtenez BEAUCOUP de règles à l’étape 1. Étant donné que la première étape peut être considérée comme uniquement une transformation de caractéristiques, vous n’avez toujours pas fini d’ajuster un modèle. Vous souhaitez également réduire le nombre de règles. En plus des règles, toutes vos caractéristiques « brutes » de votre ensemble de données d’origine seront également utilisées dans le modèle linéaire clairsemé. Chaque règle et chaque fonctionnalité originale devient une fonctionnalité dans le modèle linéaire et obtient une estimation de poids. Les caractéristiques brutes d’origine sont ajoutées car les arbres ne parviennent pas à représenter des relations linéaires simples entre <span class="math inline">\(y\)</span> et <span class="math inline">\(x\)</span>. Avant de former un modèle linéaire clairsemé, nous winsorisons les fonctionnalités d’origine afin qu’elles soient plus robustes face aux valeurs aberrantes :</p>
<p><span class="math display">\[l_j^*(x_j)=min(\delta_j^+,max(\delta_j^-,x_j))\]</span></p>
<p>où <span class="math inline">\(\delta_j^-\)</span> et <span class="math inline">\(\delta_j^+\)</span> sont les <span class="math inline">\(\delta\)</span> quantiles de la distribution des données de l’entité <span class="math inline">\(x_j\)</span>. Un choix de 0,05 pour <span class="math inline">\(\delta\)</span> signifie que toute valeur de fonctionnalité <span class="math inline">\(x_j\)</span> qui se situe dans les <span class="math inline">\(5\%\)</span> les plus basses ou les <span class="math inline">\(5\%\)</span> les plus élevées seront définies sur les quantiles à <span class="math inline">\(5\%\)</span> ou <span class="math inline">\(95\%\)</span> respectivement. En règle générale, vous pouvez choisir <span class="math inline">\(\delta = 0,025\)</span>. De plus, les termes linéaires doivent être normalisés afin qu’ils aient la même importance préalable qu’une règle de décision typique :</p>
<p><span class="math display">\[l_j(x_j)= 0,4 . l^*_j(x_j) / std(l^*_j(x_j))\]</span></p>
<p>Le <span class="math inline">\(0,4\)</span> est l’écart type moyen des règles avec une distribution de support uniforme de <span class="math inline">\(s_k\sim{}U(0,1)\)</span></p>
<p>Nous combinons les deux types de fonctionnalités pour générer une nouvelle matrice de fonctionnalités et former un modèle linéaire clairsemé avec Lasso, avec la structure suivante :</p>
<p><span class="math display">\[\hat{f}(x)=\hat{\beta}_0+\sum_{k=1}^K\hat{\alpha}_k{}r_k(x)+\sum_{j=1}^p\hat{\beta}_j{}l_j(x_j)\]</span></p>
<p>où <span class="math inline">\(\hat{\alpha}\)</span> est le vecteur de poids estimé pour les caractéristiques de la règle et <span class="math inline">\(\hat{\beta}\)</span> le vecteur de poids pour les caractéristiques d’origine. Puisque RuleFit utilise Lasso, la fonction de perte obtient la contrainte supplémentaire qui force certains poids à obtenir une estimation nulle :</p>
<p><span class="math display">\[\begin{align*}
(\{\hat{\alpha}\}_1^K,\{\hat{\beta}\}_0^p) &amp; = &amp; argmin_{\{\hat{\alpha}\}_1^K,\{\hat{\beta}\}_0^p}\sum_{i=1}^n L(y^{(i)},f(x^{(i)}))  \\
&amp; + &amp; \lambda.\left(\sum_{k=1}^K|\alpha_k| + \sum_{j=1}^p|\beta_j|\right)
\end{align*}\]</span></p>
<p>Le résultat est un modèle linéaire qui a des effets linéaires pour toutes les fonctionnalités d’origine et pour les règles. L’interprétation est la même que pour les modèles linéaires, la seule différence est que certaines fonctionnalités sont désormais des règles binaires.</p>
<p><strong>Step 3 (optional): Feature importance</strong></p>
<p>Pour les termes linéaires des caractéristiques d’origine, l’importance des caractéristiques est mesurée avec le prédicteur standardisé :</p>
<p><span class="math display">\[I_j=|\hat{\beta}_j|. std(l_j(x_j))\]</span></p>
<p>où <span class="math inline">\(\beta_j\)</span> est le poids du modèle Lasso et <span class="math inline">\(std(l_j(x_j))\)</span> est l’écart type du terme linéaire sur les données.</p>
<p>Pour les termes de la règle de décision, l’importance est calculée avec la formule suivante :</p>
<p><span class="math display">\[I_k=|\hat{\alpha}_k|.\sqrt{s_k(1-s_k)}\]</span></p>
<p>où <span class="math inline">\(\hat{\alpha}_k\)</span> est le poids Lasso associé de la règle de décision et <span class="math inline">\(s_k\)</span> est la prise en charge de la fonctionnalité dans les données, qui est le pourcentage de points de données auxquels la règle de décision s’applique (où <span class="math inline">\(r_k(x)=1\)</span>) :</p>
<p><span class="math display">\[s_k=\frac{1}{n}\sum_{i=1}^n r_k(x^{(i)})\]</span></p>
<p>Une caractéristique apparaît sous la forme d’un terme linéaire et éventuellement également dans de nombreuses règles de décision. Comment mesurons-nous l’importance totale d’une fonctionnalité ? L’importance <span class="math inline">\(J_j(x)\)</span> d’une caractéristique peut être mesurée pour chaque prédiction individuelle :</p>
<p><span class="math display">\[J_j(x)=I_j(x)+\sum_{x_j\in{}r_k}I_k(x)/m_k\]</span></p>
<p>où <span class="math inline">\(I_l\)</span> est l’importance du terme linéaire et <span class="math inline">\(I_k\)</span> l’importance des règles de décision dans lesquelles <span class="math inline">\(x_j\)</span> apparaît, et <span class="math inline">\(m_k\)</span> est le nombre de caractéristiques constituant la règle <span class="math inline">\(r_k\)</span>. L’ajout de l’importance des fonctionnalités de toutes les instances nous donne l’importance globale des fonctionnalités :</p>
<p><span class="math display">\[J_j(X)=\sum_{i=1}^n{}J_j(x^{(i)})\]</span></p>
<p>Il est possible de sélectionner un sous-ensemble d’instances et de calculer l’importance des fonctionnalités pour ce groupe.</p>
</section>
<section id="avantages" class="level3">
<h3 class="anchored" data-anchor-id="avantages">5.6.3 - Avantages</h3>
<p>RuleFit ajoute automatiquement <strong>des interactions de fonctionnalités</strong> aux modèles linéaires. Par conséquent, cela résout le problème des modèles linéaires dans lesquels vous devez ajouter manuellement des termes d’interaction et cela aide un peu à résoudre le problème de la modélisation des relations non linéaires.</p>
<p>RuleFit peut gérer à la fois les tâches de classification et de régression.</p>
<p>Les règles créées sont faciles à interpréter, car ce sont des règles de décision binaires. Soit la règle s’applique à une instance, soit non. Une bonne interprétabilité n’est garantie que si le nombre de conditions au sein d’une règle n’est pas trop grand. Une règle avec 1 à 3 conditions me semble raisonnable. Cela signifie une profondeur maximale de 3 pour les arbres de l’ensemble d’arbres.</p>
<p>Même s’il existe de nombreuses règles dans le modèle, elles ne s’appliquent pas à toutes les instances. Pour une instance individuelle, seule une poignée de règles s’appliquent (= avoir un poids non nul). Cela améliore l’interprétabilité locale.</p>
<p>RuleFit propose un tas d’outils de diagnostic utiles. Ces outils sont indépendants du modèle, vous pouvez donc les trouver dans la section indépendante du modèle du livre : <a href="../08-global_model_agnostic_methods/08.5-permutation-feature-importance.html">importance des fonctionnalités</a>, <a href="../08-global_model_agnostic_methods/08.1-pdp.html">diagrammes de dépendance partielle</a> et <a href="../08-global_model_agnostic_methods/08.3-feature-interaction.html">interactions des fonctionnalités</a>.</p>
</section>
<section id="inconvénients" class="level3">
<h3 class="anchored" data-anchor-id="inconvénients">5.6.4 - Inconvénients</h3>
<p>Parfois, RuleFit crée de nombreuses règles qui ont un poids non nul dans le modèle Lasso. L’interprétabilité se dégrade avec l’augmentation du nombre de fonctionnalités dans le modèle. Une solution prometteuse consiste à forcer les effets de caractéristiques à être monotones, ce qui signifie qu’une augmentation d’une caractéristique doit conduire à une augmentation de la prédiction.</p>
<p>Un inconvénient anecdotique : les journaux revendiquent de bonnes performances de RuleFit – souvent proches des performances prédictives des forêts aléatoires ! – mais dans les rares cas où je l’ai essayé personnellement, les performances ont été décevantes. Essayez-le simplement pour votre problème et voyez comment il fonctionne.</p>
<p>Le produit final de la procédure RuleFit est un modèle linéaire doté de fonctionnalités supplémentaires (les règles de décision). Mais comme il s’agit d’un modèle linéaire, l’interprétation du poids reste peu intuitive. Il est livré avec la même « note de bas de page » qu’un modèle de régression linéaire habituel : « … étant donné que toutes les caractéristiques sont fixes. » Cela devient un peu plus délicat lorsque les règles se chevauchent. Par exemple, une règle de décision (fonctionnalité) pour la prévision du vélo pourrait être : « température &gt; 10 » et une autre règle pourrait être « température &gt; 15 &amp; météo=‘GOOD’ ». S’il fait beau et que la température est supérieure à 15 degrés, la température est automatiquement supérieure à 10. Dans les cas où la deuxième règle s’applique, la première règle s’applique également. L’interprétation du poids estimé pour la deuxième règle est la suivante : « En supposant que toutes les autres caractéristiques restent fixes, le nombre prévu de vélos augmente de <span class="math inline">\(\beta_2\)</span> quand il fait beau et que la température est supérieure à 15 degrés. Mais maintenant, il devient très clair que « toutes les autres caractéristiques sont corrigées » est problématique, car si la règle 2 s’applique, la règle 1 s’applique également et l’interprétation est absurde.</p>
</section>
<section id="logiciels-et-alternatives" class="level3">
<h3 class="anchored" data-anchor-id="logiciels-et-alternatives">5.6.5 - Logiciels et alternatives</h3>
<p>L’algorithme RuleFit est implémenté dans R par Fokkema et Christoffersen (2017)<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> et vous pouvez trouver une <a href="https://github.com/christophM/rulefit">version Python sur GitHub</a>.</p>
<p>Un framework très similaire est <a href="https://github.com/scikit-learn-contrib/skope-rules">skope-rules</a>, un module Python qui extrait également les règles des ensembles. Il diffère dans la manière dont il apprend les règles finales : premièrement, les règles skope suppriment les règles peu performantes, sur la base de seuils de rappel et de précision. Ensuite, les règles en double et similaires sont supprimées en effectuant une sélection basée sur la diversité des termes logiques (variable + opérateur plus grand/plus petit) et les performances (score F1) des règles. Cette dernière étape ne repose pas sur l’utilisation de Lasso, mais considère uniquement le score F1 sorti du sac et les termes logiques qui forment les règles.</p>
<p>Le <a href="https://github.com/csinva/imodels">package imodels</a> contient également des implémentations d’autres ensembles de règles, tels que les ensembles de règles bayésiennes, les ensembles de règles boostés et les ensembles de règles SLIPPER en tant que package Python avec une interface scikit-learn unifiée.</p>
<!-- REFERENCES -->


</section>
</section>


<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Retour au sommet</a><div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Notes de bas de page</h2>

<ol>
<li id="fn1"><p>Friedman, Jerome H, and Bogdan E Popescu. “Predictive learning via rule ensembles.” The Annals of Applied Statistics. JSTOR, 916–54. (2008).<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Fokkema, Marjolein, and Benjamin Christoffersen. “Pre: Prediction rule ensembles”. https://CRAN.R-project.org/package=pre (2017).<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copié");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copié");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../05-interpretable_models/05.5-decision-rules.html" class="pagination-link  aria-label=" 5.5="" -="" règles="" de="" décision"="">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">5.5 - Règles de décision</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../05-interpretable_models/05.7-other-interpretable-models.html" class="pagination-link" aria-label="5.7 - Autres modèles interprétables">
        <span class="nav-page-text">5.7 - Autres modèles interprétables</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>